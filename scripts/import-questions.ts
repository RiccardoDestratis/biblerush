/**
 * Script to import question sets from JSON format into Supabase
 * 
 * Usage:
 *   pnpm tsx scripts/import-questions.ts <path-to-json-file>
 * 
 * Example:
 *   pnpm tsx scripts/import-questions.ts data/questions.json
 */

import { createClient } from '@supabase/supabase-js';
import * as dotenv from 'dotenv';
import * as fs from 'fs';
import * as path from 'path';
import { resolve } from 'path';

// Load environment variables from .env.local
dotenv.config({ path: resolve(__dirname, '../.env.local') });

// Types matching the JSON structure
type LanguageText = {
  en: string;
  de: string;
  it: string;
};

type Question = {
  question: LanguageText;
  option_a: LanguageText;
  option_b: LanguageText;
  option_c: LanguageText;
  option_d: LanguageText;
  right_answer: LanguageText;
  verse_reference: LanguageText;
  verse_content: LanguageText;
  image_prompt: string;
  image_style: string;
};

type QuestionSet = {
  set_name: LanguageText;
  set_description: LanguageText;
  difficulty: 'beginner' | 'intermediate' | 'advanced';
  questions: Question[];
};

type QuestionSetsData = {
  question_sets: QuestionSet[];
};

// Initialize Supabase client
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseServiceKey) {
  console.error('‚ùå Missing required environment variables:');
  console.error('   NEXT_PUBLIC_SUPABASE_URL:', supabaseUrl ? '‚úÖ' : '‚ùå');
  console.error('   SUPABASE_SERVICE_ROLE_KEY:', supabaseServiceKey ? '‚úÖ' : '‚ùå');
  console.error('\nMake sure your .env.local file is set up correctly.');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseServiceKey);

/**
 * Determines the correct answer letter (A, B, C, or D) by comparing
 * the right_answer text with each option
 */
function determineCorrectAnswer(
  rightAnswer: string,
  optionA: string,
  optionB: string,
  optionC: string,
  optionD: string
): 'A' | 'B' | 'C' | 'D' {
  if (rightAnswer === optionA) return 'A';
  if (rightAnswer === optionB) return 'B';
  if (rightAnswer === optionC) return 'C';
  if (rightAnswer === optionD) return 'D';
  
  // Fallback: try case-insensitive comparison
  const rightLower = rightAnswer.toLowerCase().trim();
  if (rightLower === optionA.toLowerCase().trim()) return 'A';
  if (rightLower === optionB.toLowerCase().trim()) return 'B';
  if (rightLower === optionC.toLowerCase().trim()) return 'C';
  if (rightLower === optionD.toLowerCase().trim()) return 'D';
  
  throw new Error(
    `Could not determine correct answer. Right answer: "${rightAnswer}" ` +
    `Options: A="${optionA}", B="${optionB}", C="${optionC}", D="${optionD}"`
  );
}

/**
 * Imports a question set into Supabase
 * Note: UUIDs for question_sets and questions are auto-generated by Supabase
 */
async function importQuestionSet(questionSet: QuestionSet, orderIndex: number = 0): Promise<void> {
  console.log(`\nüì¶ Importing question set: ${questionSet.set_name.en}`);
  console.log(`   Difficulty: ${questionSet.difficulty}`);
  console.log(`   Questions: ${questionSet.questions.length}`);

  // Insert question set (UUID auto-generated by Supabase)
  const { data: insertedSet, error: setError } = await supabase
    .from('question_sets')
    .insert({
      name_en: questionSet.set_name.en,
      name_de: questionSet.set_name.de,
      name_it: questionSet.set_name.it,
      description_en: questionSet.set_description.en,
      description_de: questionSet.set_description.de,
      description_it: questionSet.set_description.it,
      difficulty: questionSet.difficulty,
      question_count: questionSet.questions.length,
      is_published: true,
    })
    .select()
    .single();

  if (setError) {
    console.error(`‚ùå Error inserting question set:`, setError);
    throw setError;
  }

  console.log(`‚úÖ Question set created with ID: ${insertedSet.id}`);

  // Insert questions (UUIDs auto-generated, order_index set from array position)
  for (let i = 0; i < questionSet.questions.length; i++) {
    const question = questionSet.questions[i];
    
    // Determine correct answer letter
    const correctAnswer = determineCorrectAnswer(
      question.right_answer.en,
      question.option_a.en,
      question.option_b.en,
      question.option_c.en,
      question.option_d.en
    );

    const { error: questionError } = await supabase
      .from('questions')
      .insert({
        question_set_id: insertedSet.id,
        order_index: i + 1, // Questions are ordered by their position in the array
        // Multilingual question text
        question_en: question.question.en,
        question_de: question.question.de,
        question_it: question.question.it,
        // Multilingual options A
        option_a_en: question.option_a.en,
        option_a_de: question.option_a.de,
        option_a_it: question.option_a.it,
        // Multilingual options B
        option_b_en: question.option_b.en,
        option_b_de: question.option_b.de,
        option_b_it: question.option_b.it,
        // Multilingual options C
        option_c_en: question.option_c.en,
        option_c_de: question.option_c.de,
        option_c_it: question.option_c.it,
        // Multilingual options D
        option_d_en: question.option_d.en,
        option_d_de: question.option_d.de,
        option_d_it: question.option_d.it,
        // Correct answer (letter)
        correct_answer: correctAnswer,
        // Multilingual right answer (full text)
        right_answer_en: question.right_answer.en,
        right_answer_de: question.right_answer.de,
        right_answer_it: question.right_answer.it,
        // Multilingual verse reference
        verse_reference_en: question.verse_reference.en,
        verse_reference_de: question.verse_reference.de,
        verse_reference_it: question.verse_reference.it,
        // Multilingual verse content
        verse_content_en: question.verse_content.en,
        verse_content_de: question.verse_content.de,
        verse_content_it: question.verse_content.it,
        // Image metadata
        image_prompt: question.image_prompt,
        image_style: question.image_style,
        // Image and video locations (null for now)
        image_location: null,
        video_location: null,
      });

    if (questionError) {
      console.error(`‚ùå Error inserting question ${i + 1}:`, questionError);
      throw questionError;
    }

    console.log(`   ‚úÖ Question ${i + 1}/${questionSet.questions.length} imported`);
  }

  console.log(`‚úÖ Successfully imported question set: ${questionSet.set_name.en}`);
}

/**
 * Main import function
 */
async function main() {
  const jsonFilePath = process.argv[2];

  if (!jsonFilePath) {
    console.error('Usage: pnpm tsx scripts/import-questions.ts <path-to-json-file>');
    process.exit(1);
  }

  const fullPath = path.resolve(jsonFilePath);

  if (!fs.existsSync(fullPath)) {
    console.error(`‚ùå File not found: ${fullPath}`);
    process.exit(1);
  }

  console.log(`üìñ Reading JSON file: ${fullPath}`);

  const fileContent = fs.readFileSync(fullPath, 'utf-8');
  const data: QuestionSetsData = JSON.parse(fileContent);

  console.log(`\nüìä Found ${data.question_sets.length} question set(s) to import`);

  // Import each question set
  for (let i = 0; i < data.question_sets.length; i++) {
    try {
      await importQuestionSet(data.question_sets[i], i);
    } catch (error) {
      console.error(`\n‚ùå Failed to import question set ${i + 1}:`, error);
      process.exit(1);
    }
  }

  console.log(`\nüéâ Successfully imported all question sets!`);
}

// Run the import
main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});

